% Forgery attack on the CGI_based encryption system for a intercepted ciphertext.
% The quality of decrypted image is related to image size and the number
% of measurements.
clc;
close all;
clear all;

% simulation results of encryption and decryption obtained by authorized user.
T=imread('E:\images\secretimage.jpg');
T=rgb2gray(T);
T=double(T);
figure,imagesc(T);
colormap(gray);
title('Original secret image');

s=64; % 64*64 is the size of the secret image

r=10000;               
B_ave=0;               
I_ave=zeros(s);   
BI_ave=zeros(s);  
Sm=zeros(1,r);
D=zeros(s);
for m=1:r
    load I; %save all the intensity patterns in the matrix I, and load it.
    Im=I(1:s,1+s*(n-1):s+s*(n-1)); %extract each pattern from I.It can also be generated by rand(s), but the running time will be uncertain. 

    Sm(1,m)=sum(sum(Im.*T)); %ciphertext, single-pixel detected data
    B_ave=B_ave+(Sm(1,m))/r; %average of the ciphertext data   
    I_ave=I_ave+Im/r;        %average of the projected patterns
    BI_ave=BI_ave+((Sm(1,m))*Im)/r; %average of the {Sm*Im} 
end
O=BI_ave-B_ave*I_ave;  %decryption  
figure,imagesc(O);
colormap(gray);
title('Decrypted secret image');
axis off;
CC=corr2(T,O);

% compute the threshold.
Sm_max=max(Sm);
Sm_min=min(Sm);
Th1=(Sm_max+Sm_min)/2;

% simulation results of forgery attack.
Tf=imread('E:\fakeimage\GI.bmp');
Tf=rgb2gray(Tf);
Tf=double(Tf);
figure,imagesc(Tf);
colormap(gray);
title('Original fake image');

rf=10000;
B_avef=0;               
I_avef=zeros(s);   
BI_avef=zeros(s);  
Smf=zeros(1,rf);
Df=zeros(s);

%These thresholds need to be estimated in advance. In this experiment,
%10000 intensity patterns are random selected by rand(s) to encrypted the 
%fake image, then the threshold is estimated by the generated ciphertext. 
%The value of the threshold is related to the size of images and the number 
%of measurements.
Th2=6.474918943200065e+04;

for mf=1:rf
    Imf=rand(s);
    Smf(1,mf)=sum(sum(Imf.*Tf));
    while ((Sm(1,mf)>=Th1&Smf(1,mf)<Th2)|(Sm(1,mf)<Th1&Smf(1,mf)>=Th2))
        Imf=rand(s);
        Smf(1,mf)=sum(sum(Imf.*Tf));
    end
    I_avef=I_avef+Imf/rf;   
    BI_avef=BI_avef+((Sm(1,mf))*Imf)/rf; 
end
Of=BI_avef-B_ave*I_avef;   
figure,imagesc(Of);
colormap(gray);
title('Decrypted fake image');