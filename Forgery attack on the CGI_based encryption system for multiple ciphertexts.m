% Forgery attack on the CGI_based encryption system for multiple ciphertexts.
% e.g., four ciphertexts.
% Assume that all the ciphertexts were intercepted by attacker.
% The quality of decrypted images is related to image size and the number
% of measurements.
clc;
close all;
clear all;

% simulation results of encryption and decryption obtained by authorized user.
T1=imread('E:\images\A.bmp');
T1=rgb2gray(T1);
T1=double(T1);
figure,imagesc(T1);
colormap(gray);
title('Original secret image A');

T2=imread('E:\images\B.bmp');
T2=rgb2gray(T2);
T2=double(T2);
figure,imagesc(T2);
colormap(gray);
title('Original secret image B');

T3=imread('E:\images\C.bmp');
T3=rgb2gray(T3);
T3=double(T3);
figure,imagesc(T3);
colormap(gray);
title('Original secret image C');

T4=imread('E:\images\D.bmp');
T4=rgb2gray(T4);
T4=double(T4);
figure,imagesc(T4);
colormap(gray);
title('Original secret image D');

s=64;    % 64*64 is the size of the secret image
r=10000;               
B_ave1=0;  
B_ave2=0;  
B_ave3=0;  
B_ave4=0;  
I_ave=zeros(s);   
BI_ave1=zeros(s);  
BI_ave2=zeros(s); 
BI_ave3=zeros(s); 
BI_ave4=zeros(s); 
Sm1=zeros(1,r);
Sm2=zeros(1,r);
Sm3=zeros(1,r);
Sm4=zeros(1,r);
D=zeros(s);
for m=1:r
    load I; %save all the intensity patterns in the matrix I, and load it.
    Im=I(1:s,1+s*(n-1):s+s*(n-1)); %extract each pattern from I.It can also be generated by rand(s), but the running time will be uncertain. 

    Sm1(1,m)=sum(sum(Im.*T1));   %ciphertext, single-pixel detected data
    Sm2(1,m)=sum(sum(Im.*T2)); 
    Sm3(1,m)=sum(sum(Im.*T3)); 
    Sm4(1,m)=sum(sum(Im.*T4)); 
    B_ave1=B_ave1+(Sm1(1,m))/r;   %average of the ciphertext data  
    B_ave2=B_ave2+(Sm2(1,m))/r; 
    B_ave3=B_ave3+(Sm3(1,m))/r; 
    B_ave4=B_ave4+(Sm4(1,m))/r; 
    I_ave=I_ave+Im/r;             %average of the projected patterns
    BI_ave1=BI_ave1+((Sm1(1,m))*Im)/r; %average of the {Sm*Im}
    BI_ave2=BI_ave2+((Sm2(1,m))*Im)/r;  
    BI_ave3=BI_ave3+((Sm3(1,m))*Im)/r;  
    BI_ave4=BI_ave4+((Sm4(1,m))*Im)/r;  
end
O1=BI_ave1-B_ave1*I_ave;   
figure,imagesc(O1);
colormap(gray);
title('Decrypted secret image A');
axis off;
O2=BI_ave2-B_ave2*I_ave;   
figure,imagesc(O2);
colormap(gray);
title('Decrypted secret image B');
axis off;
O3=BI_ave3-B_ave3*I_ave;   
figure,imagesc(O3);
colormap(gray);
title('Decrypted secret image C');
axis off;
O4=BI_ave4-B_ave4*I_ave;   
figure,imagesc(O4);
colormap(gray);
title('Decrypted secret image D');
axis off;

% compute the threshold.
Sm_max1=max(Sm1);
Sm_min1=min(Sm1);
Th1=(Sm_max1+Sm_min1)/2;
Sm_max2=max(Sm2);
Sm_min2=min(Sm2);
Th2=(Sm_max2+Sm_min2)/2;
Sm_max3=max(Sm3);
Sm_min3=min(Sm3);
Th3=(Sm_max3+Sm_min3)/2;
Sm_max4=max(Sm4);
Sm_min4=min(Sm4);
Th4=(Sm_max4+Sm_min4)/2;

% simulation results of forgery attack.
Tf1=imread('E:\fakeimage\E.bmp');
Tf1=rgb2gray(Tf1);
Tf1=double(Tf1);
figure,imagesc(Tf1);
colormap(gray);
title('Original fake image E');

Tf2=imread('E:\fakeimage\F.bmp');
Tf2=rgb2gray(Tf2);
Tf2=double(Tf2);
figure,imagesc(Tf2);
colormap(gray);
title('Original fake image F');
Tf3=imread('E:\fakeimage\G.bmp');
Tf3=rgb2gray(Tf3);
Tf3=double(Tf3);
figure,imagesc(Tf3);
colormap(gray);
title('Original fake image G');
Tf4=imread('E:\fakeimage\H.bmp');
Tf4=rgb2gray(Tf4);
Tf4=double(Tf4);
figure,imagesc(Tf4);
colormap(gray);
title('Original fake image H');

rf=10000; 
B_avef1=0;   
B_avef2=0;
B_avef3=0;
B_avef4=0;
I_avef=zeros(s);   
BI_avef1=zeros(s);  
BI_avef2=zeros(s); 
BI_avef3=zeros(s); 
BI_avef4=zeros(s); 
Smf1=zeros(1,rf);
Smf2=zeros(1,rf);
Smf3=zeros(1,rf);
Smf4=zeros(1,rf);

%These thresholds need to be estimated in advance. The values are related
%to the size of images and the number of measurements
Thf1=6.189441600824217e+04;  
Thf2=4.997238765863441e+04;
Thf3=8.057639162975232e+04;
Thf4=7.428145435748971e+04;

tic;
mm=1;
for mf=1:rf
    Imf=rand(s); 
    Smf1(1,mf)=sum(sum(Imf.*Tf1));
    Smf2(1,mf)=sum(sum(Imf.*Tf2));
    Smf3(1,mf)=sum(sum(Imf.*Tf3));
    Smf4(1,mf)=sum(sum(Imf.*Tf4));
    while (((Sm1(1,mf)>=Th1&Smf1(1,mf)<Thf1)|(Sm1(1,mf)<Th1&Smf1(1,mf)>=Thf1))|((Sm2(1,mf)>=Th2&Smf2(1,mf)<Thf2)|(Sm2(1,mf)<Th2&Smf2(1,mf)>=Thf2))|((Sm3(1,mf)>=Th3&Smf3(1,mf)<Thf3)|(Sm3(1,mf)<Th3&Smf3(1,mf)>=Thf3))|((Sm4(1,mf)>=Th4&Smf4(1,mf)<Thf4)|(Sm4(1,mf)<Th4&Smf4(1,mf)>=Thf4)))
        Imf=rand(s);
        Smf1(1,mf)=sum(sum(Imf.*Tf1));
        Smf2(1,mf)=sum(sum(Imf.*Tf2));
        Smf3(1,mf)=sum(sum(Imf.*Tf3));
        Smf4(1,mf)=sum(sum(Imf.*Tf4));
        mm=mm+1;
    end
 
    I_avef=I_avef+Imf/rf;   
    BI_avef1=BI_avef1+((Sm1(1,mf))*Imf)/rf;
    BI_avef2=BI_avef2+((Sm2(1,mf))*Imf)/rf;
    BI_avef3=BI_avef3+((Sm3(1,mf))*Imf)/rf;
    BI_avef4=BI_avef4+((Sm4(1,mf))*Imf)/rf;
    mm=mm+1;
end
toc;
Of1=BI_avef1-B_ave1*I_avef;   
figure,imagesc(Of1);
colormap(gray);
title('Decrypted fake image E');
axis off;
Of2=BI_avef2-B_ave2*I_avef;   
figure,imagesc(Of2);
colormap(gray);
title('Decrypted fake image F');
axis off;
Of3=BI_avef3-B_ave3*I_avef;   
figure,imagesc(Of3);
colormap(gray);
title('Decrypted fake image G');
axis off;
Of4=BI_avef4-B_ave4*I_avef;   
figure,imagesc(Of4);
colormap(gray);
title('Decrypted fake image H');
axis off;